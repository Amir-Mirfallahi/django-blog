You are an expert full‐stack AI development agent. Your task is to build a production‐ready Django blog application, following these exact requirements. I have already created the basics for you and you have to start with those configurations and dependencies:

Project Setup

Create a new Django project called core and three apps: accounts, blog, and comment.
Containerize everything with Docker: write a Dockerfile (using Python 3.11‐slim) and a docker-compose.yml that spins up services for Django (gunicorn), PostgreSQL, Redis, Celery worker, and Redis‐beat scheduler.
Custom User Model (accounts app)

Implement User by extending AbstractBaseUser + PermissionsMixin.
Use email as the USERNAME_FIELD.
Write a custom UserManager with create_user() and create_superuser().
Blog Functionality (blog app)

Models:
Category (name, slug)
Post (title, slug, body, author→User FK, categories M2M, created_at, updated_at)
Views:
Class‐based views for list, detail, create, update, delete posts.
Filtering by category, author, and date.
Templates: Responsive HTML using Django’s template language.
Commenting System (comment app)

Model Comment with post FK, author FK, body, created_at.
Embed comment form & list on the post detail page.
Protect create/update/delete with LoginRequiredMixin.
REST API

Install Django REST Framework and drf‐yasg.
Under accounts.api, blog.api, comment.api:
CBVs and ViewSets for CRUD on User, Post, and Comment.
Routers to register all viewsets.
Serializers for each model with full validation.
Authentication

Token auth (DRF’s TokenAuthentication).
JWT via djangorestframework-simplejwt: configure /api/token/ and /api/token/refresh/.
API Documentation

Use drf‑yasg to expose Swagger at /swagger/ and ReDoc at /redoc/.
Include title, version, and license in OpenAPI info.
Testing

Write Django TestCases covering models, views, permissions, and serializers.
Add pytest support (pytest-django) and write at least equivalent pytest tests.
Ensure >90% coverage; generate a coverage report.
CI/CD

Create .github/workflows/ci.yml: on push or PR, run lint, tests, coverage.
Create .github/workflows/cd.yml: on push to main, SSH into your VPS, pull changes, and docker-compose up -d.
Data Seeding

Use faker in a custom manage.py command seed_data to populate users, categories, posts, and comments.
CORS & Headers

Install django-cors-headers and configure allowed origins.
Add any custom security headers via middleware.
Performance

Integrate Redis caching for list and detail views with @cache_page.
Write a locustfile.py that simulates anonymous browsing, authenticated post/comment creation, and run basic load tests.
Background Tasks

Configure Celery with Redis broker.
Create example tasks: one for sending a “new comment” email asynchronously, and a periodic task via Redis‑beat for cleaning up old posts.
Deployment Prep

In Docker, ensure gunicorn is entrypoint and static files are collected.
Include an Nginx config to reverse‑proxy to Gunicorn, serve static files, and handle HTTPS.
Document environment variables and secrets in an .env.example file.
VPS Setup

Provide shell commands or Ansible playbook to:
Install Docker & Docker Compose on Ubuntu.
Clone the repo.
Create .env.
Start the stack (docker-compose up -d).
Ensure firewall opens ports 80 and 443 only, and SSH on 22.
Deliver each piece incrementally as separate PRs or commits, with clear commit messages and README updates. At the end, your repo should be fully runnable via Docker Compose locally and deployable on a fresh VPS with zero manual edits. I have create the core app. The settings is located at core/core/settings.py. Don't create the django project again! The django application should locate at /core. I am going to use uv dependency manager and I have already added some packages I think we have to use. They are available at the repository directory. 